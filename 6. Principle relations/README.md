# Relations between the SOLID principles

## Context
It is interesting to observe the relations between the SOLID principles, because it could provide clearance about how the principles 'support' each other. I think there are two types of SOLID principles:
1. Theoretical principle: elaborates more on the 'why', but less on the 'how' 
2. Practical principle: elaborates more on the 'how', but less on the 'why'

The SOLID releations could help us to simplify adhering to them, because relations provide a link to stand-alone pieces that result in better remembering. 

## Relations

<img src=Relations.png width=60% height=60%>
<p> The Single Responsibility principle is dependent on the interface seggregation and Open Closed principle. SRP is about minimizing our problem window, so we can adjust, extend and test easily. I would say Single Responsibility is a theoratical principle. It contains a 'guideline' to develop high quality software, but it is really intangible when we talk about the 'how'. An expierenced software engineer understands the meaning of this abstract, intangible 'how', but it will be hard to demonstrate it to a beginner. Applying it correctly almost requires you to have a new 'sense'. </p> 
<p> Interface seggregation exists both in the practical and theoretical sense. The principle clearly explains 'how' we should comply to it and 'why'. ISP is about preventing redundant coupling, to prevent unnecessary maintainance and complexity. The relation between single responsbility comes from designing our interfaces based on the need of our client. 'Client-need' is one of the factors that determine the single responsibility of a class or interface. A class, containing a group of functions, which is often required by our clients could tell us something about the single responsibility of that class. The reduction of unnessary coupling, that results from interface seggregation, is a contribution to Single Responsibility.</p> 
<p> The open closed principle is dependent on the Liskov Substitution, Dependency Inversion and Single Responsibility principle. OCP is about preventing our working, existing code and test cases from breaking. The principle is (in my opinion) the most applicable on the functional level of the code and less on the class level. OCP is a theoratical principle. It is clear 'what' we want to achieve, but it is complex to explain 'how' to exactly accomplish this. However, one way to accomplish Open Closed is to use Dependency Inversion. DIP emphasizes the use of abstractions (i.e.: interfaces and abstract classes) and these abstractions provide an easy way to extend our system with new functionality. Dependency inversion is about change, Open Closed is about extension, which is a form of change. DIP is more the umbrella principle and the OCP resides under that umbrella to emphasize extension without modifying. DIP additionally simplifies replacement in case this is required. Replacement means removal of 'old' implementation and insertion of 'new' implementation. Dependency Inversion is a practical principle. It has a strong and clear explanation on 'how' to achieve it, but the 'why' resides more in the Open Closed principle.</p>
<p> Liskov Subsitution is another principle 'existing' in the practical 'sense'. It explains 'how' to use inheritance in a way that we can ensure that all our sub-types can be used just like our base types. We apply this principle to avoid bugs/undefined behavior and system complexity when extension is required. The more exceptional cases we have of our base contract, the more our cyclomatic complexity will increase. Inheritance is a 'resource' to achieve Open Closed and Liskov Substitution provides a way to apply this 'resource' in a correct way. This explains the relation between Liskov Substitution and Open Closed.</p>
<p>The relation between Open Closed and Single Responsibility is mutual. Ahdering to Single Responsibility will result in easy extendable code. SRP provides us clear seperation. Clear seperation provides overview that results in simplifying extension. Applying Single Responsibility on the functional level prevents us from having to modify extisting code while extending (e.g. switch-cases). It could mean that OCP arises from applying SRP 'correctly', but also the other way around.</p>
<p>Dependency inversion has a dependency towards Interface Seggregation principle and Liskov Subtitution. DIP uses interfaces and abstract classes to be adaptive to change and ISP provides a 'guideline' on how to correctly implement these abstractions. The same relation accounts between Liskov Substitution and Dependency inversion principle. LSP explains us the 'correct' usage of inheritance and inheritance is one of the techniques required to achieve DIP. </p> 
